#' @title First Frame
#'
#' @description
#' This function generates an image file of the potential first frame (in the first loop) in the .mp4 file that would be generated by generate_mp4().
#' It takes in an input function, the bound equal to the radius of the x-axis, a step size that indicates the distance between domain values, and a frequency that
#' determines the number of indices skipped between plot frames.
#'
#'
#' @param input_function         // Vector of function values for use as base function and kernel
#' @param bound                  // Radius of the x-axis for the plot
#' @param step_size              // Distance between each value in the input function
#' @param freq                   // Dictates the number of indices to skip before each frame is generated
#'
#' @import magic
#' @import magick
#' @import av
#' @import ggplot2
#' @examples
#' # Checking the first frame for a uniform distribution on (-.5, 5) with a plot radius of 2.
#'
#' x <- seq(-2, 2, by = .002)
#'
#' y <- unif(x, -.5, .5)
#'
#' first_frame(input_function = y, bound = 2, step_size = .002, freq = 4)
#'
#' @export
first_frame <- function(input_function = NULL, bound = 2, step_size = .002, freq = 4){

  # Create a and b variables based off of bound
  a <- -1* bound
  b <- 1 * bound

  # If no function is input, then default to a uniform distributin
  if(is.null(input_function)){

    x <- seq(a, b, by = step_size)

    input_function <- unif(x, -.5, .5)

  }

  # Compatibility check.
  if(length(input_function) != (2 * bound)/step_size + 1){
    warning("Input function should be defined over the domain vector: x <- seq(-bound, bound, by = step_size)")
  }

  # Create bounds to do "off - screen" calculations
  a1 <- 2*a
  b1 <- 2*b

  # Calculate corresponding indices for a and b
  a_plot <- (a - a1)/step_size
  b_plot <- (b - a1)/step_size

  # Calculate indices to begin image capturing
  start <- (a - a1)/(2*step_size)
  end <- ((b + b1)/2 - a1)/step_size

  # Create a domain including the adjusted bounds
  x_vals <- seq(a1, b1, by = step_size)

  a1 <- x_vals[1]
  b1 <- x_vals[length(x_vals)]

  # Create a vector to store the convolution of the function and the kernel
  conv <- rep(0, length(x_vals))

  # Create a vector to store the function over the adjusted domain
  func <- rep(0, length(x_vals))

  # Set the value of the function equal to the input function
  func[a_plot:b_plot] <- input_function

  # The kernel is equal to the input function, adjusted to the lowest point of the domain.
  ker <- func
  ker <- ashift(ker, -(length(x_vals)-1)/2)
  index <- 1

  # Initialize a vector to store the generated images
  plot_files <- character(1)

  for(i in 1:length(x_vals)){

    # Shift the kernel one index to the right
    ker <- ashift(ker, 1)

    # Calculate the value of the convolution at index i
    conv[i] <- convolution(func, ker, (1/step_size))

    # Identify the index corresponding to the first frame of the .mp4 file, save the frame, and end the loop.
    if((i-1) %% freq == 0 && i >= start){

      # Create adjusted vectors to fit the domain of the plot
      x_graph <- x_vals[a_plot:b_plot]
      func_graph <- func[a_plot:b_plot]
      ker_graph <- ker[a_plot:b_plot]
      conv_graph <- conv[a_plot:b_plot]

      # Create a data frame for the plot
      data <- data.frame(
        x = rep(x_graph, 3),
        y = c(func_graph, ker_graph, conv_graph),
        function_type = rep(c("Function", "Kernel", "Convolution"), each = length(x_graph))
      )

      # Generate the plot for the first frame
      plot <- ggplot(data, aes(x = x, y = y, color = function_type)) +
        geom_line(size = 1) +
        labs(title = "Last Frame", x = "X", y = "Density") +
        scale_color_manual(values = c("black", "blue", "red")) +  # Set custom colors
        theme_minimal() +
        theme(
          panel.background = element_rect(fill = "white", color = "white"),
          plot.background = element_rect(fill = "white", color = "white")
        ) +
        ylim(0,2)

      # Save the plot as a .png image
      plot_file <- paste0("first_frame.png")
      ggsave(plot_file, plot = plot, width = 5, height = 4)

      break
    }

  }

}
